#!/usr/bin/env node

const fs = require('fs').promises;
const path = require('path');
const { execSync } = require('child_process');

// Configuration
const PROJECT_ROOT = process.env.PROJECT_ROOT || path.resolve(__dirname, '../..');

// ANSI color codes for terminal output
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m',
};

// Directory descriptions - customize these for your project
const directoryDescriptions = {
  // Root level directories
  'frontend': {
    emoji: 'ðŸ–¥ï¸',
    title: 'Frontend',
    description: 'Next.js application that provides the user interface for the Tata AI platform.',
    contents: ['app', 'components', 'hooks', 'lib', 'public', 'styles']
  },
  'backend': {
    emoji: 'âš™ï¸',
    title: 'Backend',
    description: 'Backend services and API endpoints for the Tata AI platform.',
    contents: ['api', 'controllers', 'models', 'routes', 'middleware']
  },
  'src': {
    emoji: 'ðŸ§ ',
    title: 'Source',
    description: 'Core source code for the Tata AI modules and shared components.',
    contents: ['tata-core', 'tata-flow', 'tata-memex', 'tata-moto', 'tata-zkp', 'shared']
  },
  'scripts': {
    emoji: 'ðŸ› ï¸',
    title: 'Scripts',
    description: 'Utility scripts for development, deployment, and maintenance of the Tata AI platform.',
    contents: ['frontend', 'backend', 'general', 'docker', 'deployment', 'setup', 'testing', 'model']
  },
  'docker': {
    emoji: 'ðŸ³',
    title: 'Docker',
    description: 'Docker configuration files and container definitions for the Tata AI platform.',
    contents: ['tata-core', 'tata-flow', 'tata-memex', 'tata-moto', 'tata-zkp', 'reports']
  },
  'configs': {
    emoji: 'âš™ï¸',
    title: 'Configurations',
    description: 'Configuration files for various components of the Tata AI platform.',
    contents: ['database', 'api', 'security', 'models', 'templates']
  },
  'data': {
    emoji: 'ðŸ“Š',
    title: 'Data',
    description: 'Data storage for models, raw data, and processed data used by the Tata AI platform.',
    contents: ['models', 'raw', 'processed']
  },
  'logs': {
    emoji: 'ðŸ“',
    title: 'Logs',
    description: 'Log files generated by the Tata AI platform components.',
    contents: ['frontend', 'backend', 'services', 'system']
  },
  'docs': {
    emoji: 'ðŸ“š',
    title: 'Documentation',
    description: 'Documentation for the Tata AI platform, including API references and user guides.',
    contents: ['api', 'user-guides', 'development', 'deployment']
  },
  'tests': {
    emoji: 'ðŸ§ª',
    title: 'Tests',
    description: 'Test suites for the Tata AI platform components.',
    contents: ['unit', 'integration', 'e2e', 'performance']
  },
  'monitoring': {
    emoji: 'ðŸ“ˆ',
    title: 'Monitoring',
    description: 'Monitoring configurations and scripts for the Tata AI platform.',
    contents: ['configs', 'scripts', 'dashboards']
  },
  
  // Source module directories
  'src/tata-core': {
    emoji: 'ðŸ§ ',
    title: 'Tata Core',
    description: 'Central orchestration service that coordinates all other Tata AI modules.',
    contents: ['api', 'controllers', 'services', 'models', 'utils']
  },
  'src/tata-flow': {
    emoji: 'ðŸ”„',
    title: 'Tata Flow',
    description: 'Workflow management service for AI processing pipelines.',
    contents: ['workflows', 'processors', 'connectors', 'templates']
  },
  'src/tata-memex': {
    emoji: 'ðŸ’¾',
    title: 'Tata Memex',
    description: 'Memory extension service for storing and retrieving AI knowledge.',
    contents: ['storage', 'retrieval', 'indexing', 'embedding']
  },
  'src/tata-moto': {
    emoji: 'ðŸ¤–',
    title: 'Tata Moto',
    description: 'AI model training and inference service.',
    contents: ['training', 'inference', 'models', 'evaluation']
  },
  'src/tata-zkp': {
    emoji: 'ðŸ”',
    title: 'Tata ZKP',
    description: 'Zero-knowledge proof service for secure AI operations.',
    contents: ['proofs', 'verification', 'crypto', 'protocols']
  },
  
  // Script subdirectories
  'scripts/frontend': {
    emoji: 'ðŸ–¥ï¸',
    title: 'Frontend Scripts',
    description: 'Scripts for frontend development, building, and deployment.',
    contents: ['build', 'deploy', 'test', 'analyze']
  },
  'scripts/backend': {
    emoji: 'âš™ï¸',
    title: 'Backend Scripts',
    description: 'Scripts for backend development, deployment, and maintenance.',
    contents: ['deploy', 'migrate', 'seed', 'test']
  },
  'scripts/general': {
    emoji: 'ðŸ”§',
    title: 'General Scripts',
    description: 'General utility scripts for the Tata AI platform.',
    contents: ['check_project', 'update_readme', 'setup', 'cleanup']
  },
  
  // Default for unknown directories
  'default': {
    emoji: 'ðŸ“',
    title: 'Directory',
    description: 'A component of the Tata AI platform.',
    contents: []
  }
};

// Utility functions
async function fileExists(filePath) {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

async function isDirectory(dirPath) {
  try {
    const stats = await fs.stat(dirPath);
    return stats.isDirectory();
  } catch {
    return false;
  }
}

// Get subdirectories of a directory
async function getSubdirectories(dirPath) {
  try {
    const items = await fs.readdir(dirPath);
    const subdirs = [];
    
    for (const item of items) {
      if (item.startsWith('.')) continue; // Skip hidden files/directories
      
      const itemPath = path.join(dirPath, item);
      if (await isDirectory(itemPath)) {
        subdirs.push(item);
      }
    }
    
    return subdirs;
  } catch (error) {
    console.error(`${colors.red}Error reading directory ${dirPath}:${colors.reset}`, error.message);
    return [];
  }
}

// Generate README for a directory
async function generateDirectoryReadme(dirPath, relativePath) {
  const readmePath = path.join(dirPath, 'README.md');
  
  // Skip if README already exists
  if (await fileExists(readmePath)) {
    console.log(`${colors.yellow}âš  README.md already exists in ${relativePath}, skipping${colors.reset}`);
    return false;
  }
  
  // Get directory info
  const dirInfo = directoryDescriptions[relativePath] || directoryDescriptions['default'];
  const dirName = path.basename(dirPath);
  const title = dirInfo.title || dirName.charAt(0).toUpperCase() + dirName.slice(1);
  
  // Get subdirectories
  const subdirs = await getSubdirectories(dirPath);
  
  // Generate README content
  let readmeContent = `# ${dirInfo.emoji} ${title}

## Purpose

${dirInfo.description || `This directory contains components for the ${title} module of the Tata AI platform.`}

## Metadata

- **Type**: ${relativePath.includes('src') ? 'Service' : relativePath.includes('scripts') ? 'Utility' : 'Component'}
- **Status**: Active
- **Last Updated**: ${new Date().toISOString().split('T')[0]}
- **Maintainer**: Tata AI Team

`;

  // Add contents section if there are subdirectories or specified contents
  const contentsToShow = subdirs.length > 0 ? subdirs : dirInfo.contents;
  
  if (contentsToShow && contentsToShow.length > 0) {
    readmeContent += `## Contents

`;
    
    for (const subdir of contentsToShow) {
      // Check if this is an actual subdirectory or just a listed content
      const subdirExists = subdirs.includes(subdir);
      const subdirPath = path.join(relativePath, subdir);
      const subdirInfo = directoryDescriptions[subdirPath] || directoryDescriptions['default'];
      
      const emoji = subdirInfo.emoji || 'ðŸ“';
      const description = subdirExists 
        ? (subdirInfo.description || `Components for the ${subdir} module.`)
        : `(Planned) ${subdirInfo.description || `Components for the ${subdir} module.`}`;
      
      readmeContent += `- **${emoji} ${subdir}**: ${description}\n`;
    }
    
    readmeContent += '\n';
  }

  // Add relationships section
  readmeContent += `## Relationships

- **Part of**: Tata AI Platform
`;

  if (relativePath.startsWith('src/')) {
    readmeContent += `- **Interfaces with**: Other Tata AI modules
`;
  }

  if (relativePath.includes('frontend')) {
    readmeContent += `- **Depends on**: Backend APIs
`;
  }

  if (relativePath.includes('backend')) {
    readmeContent += `- **Used by**: Frontend components
`;
  }

  // Add usage section
  readmeContent += `
## Usage

This directory is part of the Tata AI platform. For more information, see the main [README.md](${path.relative(dirPath, path.join(PROJECT_ROOT, 'README.md'))}) file.

`;

  // Add timestamp
  readmeContent += `---

*This README was automatically generated on ${new Date().toISOString()}.*
`;

  // Write the README file
  try {
    await fs.writeFile(readmePath, readmeContent);
    console.log(`${colors.green}âœ“ Generated README.md for ${relativePath}${colors.reset}`);
    return true;
  } catch (error) {
    console.error(`${colors.red}âœ˜ Failed to generate README.md for ${relativePath}: ${error.message}${colors.reset}`);
    return false;
  }
}

// Process a directory and its subdirectories recursively
async function processDirectory(dirPath, relativePath = '', depth = 0, maxDepth = 2) {
  if (depth > maxDepth) return;
  
  // Skip node_modules, .git, etc.
  if (path.basename(dirPath).startsWith('.') || 
      path.basename(dirPath) === 'node_modules' ||
      path.basename(dirPath) === 'venv') {
    return;
  }
  
  // Generate README for this directory
  await generateDirectoryReadme(dirPath, relativePath);
  
  // Process subdirectories
  const subdirs = await getSubdirectories(dirPath);
  
  for (const subdir of subdirs) {
    const subdirPath = path.join(dirPath, subdir);
    const subdirRelativePath = relativePath ? path.join(relativePath, subdir) : subdir;
    
    await processDirectory(subdirPath, subdirRelativePath, depth + 1, maxDepth);
  }
}

// Main function
async function main() {
  console.log(`${colors.magenta}=== Tata AI Directory README Generator ===${colors.reset}`);
  console.log(`${colors.blue}Generating READMEs for directories in: ${PROJECT_ROOT}${colors.reset}`);
  
  if (!await fileExists(PROJECT_ROOT)) {
    console.error(`${colors.red}âœ˜ Project root directory not found at ${PROJECT_ROOT}${colors.reset}`);
    console.log(`${colors.yellow}Set the PROJECT_ROOT environment variable to the correct path or update the script.${colors.reset}`);
    process.exit(1);
  }
  
  // Process the project root and its subdirectories
  await processDirectory(PROJECT_ROOT);
  
  console.log(`\n${colors.green}Directory README generation complete!${colors.reset}`);
  console.log(`${colors.blue}Note: Existing README.md files were not overwritten.${colors.reset}`);
}

// Run the script
main().catch(error => {
  console.error(`${colors.red}Error running directory README generator:${colors.reset}`, error);
  process.exit(1);
});
